# -*- coding: utf-8 -*-
"""offline_data_augmentation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1O0t93bmxqGNvNaVmyl-6j3PGwfCgDWCf

#**REDE NEURAL CONVOLUCIONAL HÍBRIDA PARA DETECÇÃO E CLASSIFICAÇÃO DE DEFEITOS EM IMAGENS ELETROLUMINESCENTES DE CÉLULAS FOTOVOLTAICAS**


#### O projeto está dividido nas seguintes etapas:

- **Aumento de Dados com aplicação de técnicas de variação geométrica**:
  - Rotacionamento das imagens em 90° no sentido horário e anti-horário ✅
  - Espelhamento (Flip)
  - Zoom (0 a 10%)
  - Borramento
  - Aumento do brilho (+20%)

### **Bibliotecas necessárias para a abertura da base de dados e ligação do Google Drive com o Colab**
"""

import glob
from skimage import io
from google.colab import drive
drive.mount('/content/gdrive')

"""### **Bibliotecas necessárias para o Pré-Processamento**"""

import cv2
from skimage.color import rgb2gray

"""### **Bibliotecas necessárias para a manipulação de dados, vetores, strings, plotagem de imagens, etc.**"""

import numpy as np
from matplotlib import pyplot as plt
import seaborn as sns
import pandas as pd
import random

"""### **Bibliotecas necessárias para a realização do _data augmentation_**"""

import albumentations as A
from albumentations import Compose, Rotate, Flip, Blur, RandomBrightnessContrast, Resize
import os

"""## **Seção 0 - Acesso à Base de Dados**

Acessando as imagens e copiando para um diretório temporário no GDrive.
"""

# Realiza a cópia da pasta com as imagens para o ambiente colab chamado dataset
!cp -R /content/gdrive/MyDrive/_code_dissertacao/dataset/_brilho_update/ dataset/

# Carrega todas as imagens da pasta dataset com formato .png
paths = glob.glob('/content/dataset/*.png')

# Ordena os caminhos das pastas em ordem alfabética
paths = sorted(paths)

# Realiza a cópia do arquivo .csv para a pasta dataset
!cp -R /content/gdrive/MyDrive/_code_dissertacao/dataset/dataset_labels.csv dataset/

"""## **Seção 1 - Offline Data Augmentation  (``Espelhamento``)**

- Aumento de dados offiline utilizando técnicas de variação geométrica:

  - **Rotacionamento das imagens em 90° no sentido horário e anti-horário** ✅
  - **Espelhamento** ✅
  - Zoom (0 a 10%)
  - Borramento
  - Aumento do brilho (+20%)
  - CLAHE

"""

# Recebe o caminho das imagens do dataset
images_dir = '/content/dataset'

# Carregar os dados do arquivo .csv usando o Pandas
labels = pd.read_csv("/content/dataset/dataset_labels.csv", sep=';')  # Substitua pelo caminho correto

# Criar um objeto de transformação usando a biblioteca Albumentations
transform = Compose([
    Flip(p=1)  # Espelhamento
])

# Loop através do DataFrame para aplicar o aumento de dados a cada imagem
for index, row in labels.iterrows():
    image_name = row['image']
    image_class = row['prob_defect']
    image_type_cells = row['type_cell']

    # Carregar a imagem usando o OpenCV
    image_path = os.path.join(images_dir, image_name)
    img = cv2.imread(image_path)

    if img is None:
        continue  # Ignorar imagens que não foram carregadas corretamente

    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)  # Converter de BGR para RGB
    img = img.astype(np.uint8)  # Certificar-se de que o tipo seja uint8

    # Aplicar as transformações de data augmentation
    augmented_image = transform(image=img)['image']

    # Salvar a nova imagem aumentada em um diretório específico
    augmented_image_name = image_name  # Manter o mesmo nome da imagem original
    augmented_image_path = os.path.join("/content/gdrive/MyDrive/_code_dissertacao/data/_teste_flip", augmented_image_name)
    cv2.imwrite(augmented_image_path, augmented_image)

    # Atualizar o arquivo .csv com o nome da nova imagem aumentada e sua classe
    new_row = {'image': augmented_image_name, 'prob_defect': image_class, 'type_cell': image_type_cells}
    labels = labels.append(new_row, ignore_index=True)

# Salvar o DataFrame atualizado em um novo arquivo .csv
# labels.to_csv("/content/gdrive/MyDrive/_code_dissertacao/data/_teste_flip/labels_flip_augmentation.csv", index=False)  # Substitua pelo caminho correto

"""## **Seção 2 - Offline Data Augmentation (Zoom)**

- Aumento de dados offiline utilizando técnicas de variação geométrica:

  - **Rotacionamento das imagens em 90° no sentido horário e anti-horário** ✅
  - **Espelhamento** ✅
  - **Zoom (0 a 10%)** ❌
  - Borramento
  - Aumento do brilho (+20%)
  - CLAHE

"""

# Recebe o caminho das imagens do dataset
images_dir = '/content/dataset/'

# Carregar os dados do arquivo .csv usando o Pandas
labels = pd.read_csv("/content/dataset/labels.csv", sep=';')  # Substitua pelo caminho correto

# Loop através do DataFrame para aplicar o aumento de dados a cada imagem
for index, row in labels.iterrows():
    image_name = row['image']
    image_class = row['prob_defect']
    image_type_cells = row['type_cell']

    # Carregar a imagem usando o OpenCV
    image_path = os.path.join(images_dir, image_name)
    img = cv2.imread(image_path)

    if img is None:
        continue  # Ignorar imagens que não foram carregadas corretamente

    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)  # Converter de BGR para RGB
    img = img.astype(np.uint8)  # Certificar-se de que o tipo seja uint8

    # Criar um objeto de transformação usando a biblioteca Albumentations
    transform = Compose([
        Resize(width=int(img.shape[1] * 2), height=int(img.shape[0] * 2), p=1),  # Zoom em 20%
        # Adicione outras transformações aqui, se desejado
    ])

    # Aplicar as transformações de data augmentation
    augmented_image = transform(image=img)['image']

    # Salvar a nova imagem aumentada em um diretório específico
    augmented_image_name = image_name  # Manter o mesmo nome da imagem original
    augmented_image_path = os.path.join("/content/gdrive/MyDrive/_code_dissertacao/data/data_augmentation_zoom", augmented_image_name)
    cv2.imwrite(augmented_image_path, augmented_image)

    # Atualizar o arquivo .csv com o nome da nova imagem aumentada e suas informações
    new_row = {'image': augmented_image_name, 'prob_defect': image_class, 'type_cell': image_type_cells}
    labels = labels.append(new_row, ignore_index=True)

# Salvar o DataFrame atualizado em um novo arquivo .csv
labels.to_csv("/content/gdrive/MyDrive/_code_dissertacao/data/data_augmentation_zoom/labels_augmentation.csv", index=False)  # Substitua pelo caminho correto

"""## **Seção 3 - Offline Data Augmentation (Borramento)**

- Aumento de dados offiline utilizando técnicas de variação geométrica:

  - **Rotacionamento das imagens em 90° no sentido horário e anti-horário** ✅
  - **Espelhamento** ✅
  - **Zoom (0 a 10%)** ❌
  - **Borramento** ✅
  - Aumento do brilho (+20%)
  - CLAHE
"""

# Recebe o caminho das imagens do dataset
images_dir = '/content/dataset'

# Carregar os dados do arquivo .csv usando o Pandas
labels = pd.read_csv("/content/dataset/dataset_labels.csv", sep=';')  # diretório do arquivo .csv

# Criar um objeto de transformação usando a biblioteca Albumentations
transform = Compose([
    Blur(blur_limit=(10, 15), p=1.0),  # Borramento
])

# Loop através do DataFrame para aplicar o aumento de dados a cada imagem
for index, row in labels.iterrows():
    image_name = row['image']
    image_class = row['prob_defect']
    image_type_cells = row['type_cell']

    # Carregar a imagem usando o OpenCV
    image_path = os.path.join(images_dir, image_name)
    img = cv2.imread(image_path)

    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)  # Converter de BGR para RGB
    img = img.astype(np.uint8)  # Certificar-se de que o tipo seja uint8

    # Aplicar as transformações de data augmentation
    augmented_image = transform(image=img)['image']

    # Salvar a nova imagem aumentada em um diretório específico
    augmented_image_name = image_name  # Manter o mesmo nome da imagem original
    augmented_image_path = os.path.join("/content/gdrive/MyDrive/_code_dissertacao/data/_teste_borramento", augmented_image_name)
    cv2.imwrite(augmented_image_path, augmented_image)

    # Atualizar o arquivo .csv com o nome da nova imagem aumentada e sua classe
    new_row = {'image': augmented_image_name, 'prob_defect': image_class, 'type_cell': image_type_cells}
    labels = labels.append(new_row, ignore_index=True)

# Salvar o DataFrame atualizado em um novo arquivo .csv
labels.to_csv("/content/gdrive/MyDrive/_code_dissertacao/data/_teste_borramento/labels_borramento.csv", index=False)

"""## **Seção 4 - Offline Data Augmentation (Aumento do Brilho)**

- Aumento de dados offiline utilizando técnicas de variação geométrica:

  - **Rotacionamento das imagens em 90° no sentido horário e anti-horário** ✅
  - **Espelhamento** ✅
  - **Zoom (0 a 10%)** ❌
  - **Borramento** ✅
  - **Aumento do brilho (+20%)** ✅
  - CLAHE
"""

from albumentations import Compose
from albumentations.augmentations import functional as F

# Recebe o caminho das imagens do dataset
images_dir = '/content/dataset'

# Carregar os dados do arquivo .csv usando o Pandas
labels = pd.read_csv("/content/dataset/dataset_labels.csv", sep=';')  # diretório do arquivo .csv

# Criar um objeto de transformação usando a biblioteca Albumentations
transform = Compose([])  # Você não precisa de outras transformações além do brilho

# Loop através do DataFrame para aplicar o aumento de dados a cada imagem
for index, row in labels.iterrows():
    image_name = row['image']
    image_class = row['prob_defect']
    image_type_cells = row['type_cell']

    # Carregar a imagem usando o OpenCV
    image_path = os.path.join(images_dir, image_name)
    img = cv2.imread(image_path)

    if img is None:
        continue  # Ignorar imagens que não foram carregadas corretamente

    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)  # Converter de BGR para RGB
    img = img.astype(np.uint8)  # Certificar-se de que o tipo seja uint8

    # Aumentar o brilho em 20%
    img = F.brightness_contrast_adjust(img, alpha=1.1, beta=0)  # Aumenta o brilho em 20%

    # Certificar-se de que os valores de pixel estejam no intervalo [0, 255]
    img = np.clip(img, 0, 255).astype(np.uint8)

    # Salvar a nova imagem aumentada em um diretório específico
    augmented_image_name = image_name  # Manter o mesmo nome da imagem original
    augmented_image_path = os.path.join("/content/gdrive/MyDrive/_code_dissertacao/data/_teste_brilho", augmented_image_name)
    cv2.imwrite(augmented_image_path, img)

    # Atualizar o arquivo .csv com o nome da nova imagem aumentada e sua classe
    new_row = {'image': augmented_image_name, 'prob_defect': image_class, 'type_cell': image_type_cells}
    labels = labels.append(new_row, ignore_index=True)

# Salvar o DataFrame atualizado em um novo arquivo .csv
labels.to_csv("/content/gdrive/MyDrive/_code_dissertacao/data/_teste_brilho/labels_brilho.csv", index=False)

print('Etapa finalizada. As novas imagens já foram geradas.')